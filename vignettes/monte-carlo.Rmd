---
title: "Monte Carlo Simulations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Monte Carlo Simulations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
We provide several functions for Monte Carlo simulations to assess the 
performance of the outlier detection algorithm `outlier_detection()` and the 
various statistical tools such as `outliers_prop()`. The simulations can be
executed in parallel using various backends.

Monte Carlo simulations involve the following steps:

1. create or choose a *true* 2SLS model (including parameters)
2. specify the outlier detection algorithm to be analysed
3. *optionally* choose which simulation parameters to vary, such as the sample
size
4. choose whether to execute the simulations sequentially or in parallel
5. run the simulations using the provided functions

# Step 1: True model
We conceptualise data as being generated by some *true* model, the so-called
data-generating process (DGP). Specifying a DGP ourselves in simulations, allows
us to check whether the theory works in practice. For example, we could use
Monte Carlo simulations to check whether the 2SLS estimator recovers the true
parameters; whether the proportion of detected outliers corresponds to the 
expected proportion; or whether a statistical test has expected size even in
finite samples.

First of all, we need to specify a valid 2SLS model and its parameters. The
function `generate_param()` can be used to generate random parameters of a 2SLS
model that fulfill the 2SLS conditions. For instance, the parameters are created
such that the structural error is uncorrelated to the instruments. Instead of 
random parameters, they can also - partly or fully - be specified by the user.

```{r}
library(r2sls)
p <- generate_param(dx1 = 3, dx2 = 2, dz2 = 3, intercept = TRUE, seed = 42)
```

Here, we create parameters for a model with 3 exogenous and 2 endogenous 
regressors, and 3 outside instruments. The model includes an intercept, so one
of the exogenous instruments is simply a constant. The parameters are stored in
a list.

Structural equation: $y_{i} = \beta_{1} x_{1,i} + \beta_{2} x_{2,i} + \beta_{3} x_{3,i} + \beta_{4} x_{4,i} + \beta_{5} x_{5,i} + u_{i}$
First stage:

# Step 4: Choosing backend for execution
The functions `mc()` and `mc_grid()` are designed to be used either sequentially
or in parallel. They are implemented using the 
[foreach](https://cran.r-project.org/web/packages/foreach/index.html) package.
To ensure that the results are reproducible across different ways of executing 
the simulations (sequentially or parallel; within the latter as multisession, 
multicore, cluster etc.), the package 
[doRNG](https://cran.r-project.org/web/packages/doRNG/index.html) is used to
execute the loops.

The Monte Carlo functions leave the registration of the foreach adaptor to the
end-user. For example, both the packages 
[doParallel](https://cran.r-project.org/web/packages/doParallel/index.html) and
[doFuture](https://cran.r-project.org/web/packages/doFuture/index.html) can be
used.

```{r}
#library(r2sls)
#library(doParallel)
#ncores <- min(max(detectCores() - 1, 1), 2)
#cl <- makeCluster(ncores)
#registerDoParallel(cl)
#clusterCall(cl, function(x) .libPaths(x), .libPaths())
#sim1 <- mc_grid(M = 100, n = 100, seed = 42, parameters = p, 
#               formula = p$setting$formula, ref_dist = "normal", 
#               sign_level = 0.05, initial_est = "robustified", iterations = 0,
#               shuffle = FALSE, shuffle_seed = 42, split = 0.5)
#stopCluster(cl)
```

```{r}
library(r2sls)
library(doFuture)
library(parallel)
ncores <- min(max(detectCores() - 1, 1), 2)
registerDoFuture()
plan(cluster, workers = ncores)
sim2 <- mc_grid(M = 100, n = 100, seed = 42, parameters = p, 
               formula = p$setting$formula, ref_dist = "normal", 
               sign_level = 0.05, initial_est = "robustified", iterations = 0,
               shuffle = FALSE, shuffle_seed = 42, split = 0.5)
```

```{r}
library(r2sls)
library(doFuture)
library(parallel)
ncores <- min(max(detectCores() - 1, 1), 2)
registerDoFuture()
plan(sequential)
sim3 <- mc_grid(M = 100, n = 100, seed = 42, parameters = p, 
               formula = p$setting$formula, ref_dist = "normal", 
               sign_level = 0.05, initial_est = "robustified", iterations = 0,
               shuffle = FALSE, shuffle_seed = 42, split = 0.5)
```

```{r}
#identical(sim1, sim2)
identical(sim2, sim3)
```






